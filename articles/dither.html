<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Dithering: a visual introduction</title><meta name="next-head-count" content="3"/><meta name="description" content="My website :)"/><link rel="icon" href="/favicon.svg"/><link rel="preload" href="/_next/static/css/57969c890d00e3cb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/57969c890d00e3cb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1804a6f845f5c415.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1804a6f845f5c415.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-01df828e572375b9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3d60e35c8f6a0ecb.js" defer=""></script><script src="/_next/static/chunks/232-366cb846acf36adb.js" defer=""></script><script src="/_next/static/chunks/pages/articles/dither-b434289ce82fcfa3.js" defer=""></script><script src="/_next/static/78eLqVSpZallak_ZN_6EA/_buildManifest.js" defer=""></script><script src="/_next/static/78eLqVSpZallak_ZN_6EA/_ssgManifest.js" defer=""></script><script src="/_next/static/78eLqVSpZallak_ZN_6EA/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Common_layoutRoot__VcayH"><header class="Common_mainContent__JJZd4 Common_header__jh1_2"><div><nav class="Crumbs_crumbs__ETs2q"><span class="Crumbs_crumb__7lg_0"><a href="/">home</a>/</span><span class="Crumbs_crumb__7lg_0"><a href="/articles">articles</a>/</span></nav><h1>Dithering: a visual introduction</h1></div></header><aside class="Common_mainContent__JJZd4 Common_settings__PgHOK"><div class="Settings_anchor__3UI96"><div class="Settings_container__lx6oR"><button class="Settings_expandToggle__2bdJ3" aria-label="Open/close settings"><div class="ExpandToggle_expandToggle__BYlBk"><span style="--n:-1"></span><span style="--n:0"></span><span style="--n:1"></span></div></button><button aria-label="Theme toggle" style="--n:1"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="1em" height="1em" class="ThemeToggle_themeToggle__1UodW" fill="currentColor" viewBox="0 0 32 32"><clipPath id="theme-toggle__within__clip"><path d="M0 0h32v32h-32ZM6 16A1 1 0 0026 16 1 1 0 006 16"></path></clipPath><g clip-path="url(#theme-toggle__within__clip)"><path d="M30.7 21.3 27.1 16l3.7-5.3c.4-.5.1-1.3-.6-1.4l-6.3-1.1-1.1-6.3c-.1-.6-.8-.9-1.4-.6L16 5l-5.4-3.7c-.5-.4-1.3-.1-1.4.6l-1 6.3-6.4 1.1c-.6.1-.9.9-.6 1.3L4.9 16l-3.7 5.3c-.4.5-.1 1.3.6 1.4l6.3 1.1 1.1 6.3c.1.6.8.9 1.4.6l5.3-3.7 5.3 3.7c.5.4 1.3.1 1.4-.6l1.1-6.3 6.3-1.1c.8-.1 1.1-.8.7-1.4zM16 25.1c-5.1 0-9.1-4.1-9.1-9.1 0-5.1 4.1-9.1 9.1-9.1s9.1 4.1 9.1 9.1c0 5.1-4 9.1-9.1 9.1z"></path></g><path class="ThemeToggle_themeToggleCircle__elMqT" d="M16 7.7c-4.6 0-8.2 3.7-8.2 8.2s3.6 8.4 8.2 8.4 8.2-3.7 8.2-8.2-3.6-8.4-8.2-8.4zm0 14.4c-3.4 0-6.1-2.9-6.1-6.2s2.7-6.1 6.1-6.1c3.4 0 6.1 2.9 6.1 6.2s-2.7 6.1-6.1 6.1z"></path><path class="ThemeToggle_themeToggleInner__B9q16" d="M16 9.5c-3.6 0-6.4 2.9-6.4 6.4s2.8 6.5 6.4 6.5 6.4-2.9 6.4-6.4-2.8-6.5-6.4-6.5z"></path></svg></button><button aria-label="Font toggle" style="--n:2"><div class="FontToggle_fontToggle__ojJQ1"><span class="FontToggle_sans__hUf61">A</span><span class="FontToggle_serif__qkIvr">A</span></div></button></div></div></aside><main class="Common_mainContent__JJZd4"><progress class="ScrollProgress_progress__XLEnH" max="100" value="0"></progress><article><h2>What is dithering?</h2>
<p>Dither is noise introduced to an image to reduce large-scale patterns like color banding when using a limited color palette. In other words, it&#x27;s a way to trick the eye into seeing more colors than are actually being displayed.</p>
<p>The human eye can only see detail up to a certain point, beyond which it starts to blur things together. The image below is a grid of alternating black and white tiles. Try zooming all the way out by dragging the Zoom slider to the left:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG"><canvas class="DemoCommon_canvas__RJB50"></canvas></div><div class="DemoCommon_controls___YFhV"><label>Zoom<input type="range" autoComplete="off" value="1" min="0" max="1" step="0.005"/></label></div></div>
<p>At larger sizes, the tiles are clearly visible, but as you zoom out they start to blend together into gray. This is an illusion: your display is really only showing pure black and white pixels, but your eyes can&#x27;t see that much detail and instead mix together equal parts black and white into gray.</p>
<p>The last example used an equal amount of black and white tiles, resulting in a 50% gray. We can change the shade of the perceived color by making more or fewer of the “tiles” or pixels black or white. Try moving the brightness slider toward both ends:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG"><canvas class="DemoCommon_canvas__RJB50"></canvas></div><div class="DemoCommon_controls___YFhV"><label>Zoom<input type="range" autoComplete="off" value="1" min="0" max="1" step="0.005"/></label><label>Brightness<input type="range" autoComplete="off" value="8" min="0" max="16" step="1"/></label></div></div>
<p>By altering the <em>ratio</em> of white to black pixels, we can make the resulting gray brighter or darker. More white pixels make the rectangle lighter on average, and so it looks brighter, while more black pixels make it darker. At each end, all pixels are either black or white and that&#x27;s the color you see.</p>
<p>This doesn&#x27;t just work for black and white, rather, we can use it to “mix” any two colors:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG"><canvas class="DemoCommon_canvas__RJB50"></canvas></div><div class="DemoCommon_controls___YFhV"><label>Zoom<input type="range" autoComplete="off" value="1" min="0" max="1" step="0.005"/></label><label>Balance<input type="range" autoComplete="off" value="8" min="0" max="16" step="1"/></label></div></div>
<p>And the effect isn&#x27;t limited to just two colors, either. In the example below, black is mixed with the three RGB primaries to approximate almost any color. You can play around with the RGB sliders to change the “target” color we&#x27;re trying to match, which is shown in the box at the top.</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG"><canvas class="DemoCommon_canvas__RJB50"></canvas><div class="DemoDitherRGB_colorPreview__fBxyZ"></div></div><div class="DemoCommon_controls___YFhV"><label>Zoom<input type="range" autoComplete="off" value="0" min="0" max="1" step="0.005"/></label><label>Red<input type="range" autoComplete="off" value="0.5" min="0" max="1" step="0.00390625" style="--progress-color:rgb(127.5,0,0)"/></label><label>Green<input type="range" autoComplete="off" value="0.5" min="0" max="1" step="0.00390625" style="--progress-color:rgb(0,127.5,0)"/></label><label>Blue<input type="range" autoComplete="off" value="0.5" min="0" max="1" step="0.00390625" style="--progress-color:rgb(0,0,127.5)"/></label></div></div>
<p>This is the working principle of dithering: by mixing a few base colors in tiny patterns, we can trick our eyes into seeing the shades in between that we can&#x27;t actually display.</p>
<h2><em>Why</em> dithering?</h2>
<p>Modern displays and image formats can display some 16.7 <em>million</em> colors. That&#x27;s a lot. This hasn&#x27;t always been the case, though. Back in the early days of computers, most devices had monochrome screens with only a few brightness levels. Early color displays supported as few as 16 or even just <em>four</em> colors at a time. Even as late as the early 2000s there were still people using 256-color displays—hence the 216-color “web safe” palette—and some popular image formats were limited to a 256 color palette as well.</p>
<p>In these low-color scenarios, dithering helps reduce color banding and effectively increases the number of colors we can display. Generally speaking, dithered images just look much better (click each image to view in detail):</p>
<div class="ImageGrid_grid__gBvFf ImageGrid_pixelated__S3xRt"><figure><picture><source srcSet="/content/articles/dither/boat-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/boat-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/boat-original.jpeg" alt="Original image"/></picture><figcaption>24-bit “true color”</figcaption></figure><figure><picture><source srcSet="/content/articles/dither/boat-web.webp" type="image/webp"/><source srcSet="/content/articles/dither/boat-web.jpeg" type="image/jpeg"/><img src="/content/articles/dither/boat-web.jpeg" alt="Web safe image"/></picture><figcaption>Web safe palette (216 colors)</figcaption></figure><figure><picture><source srcSet="/content/articles/dither/boat-web-dither.webp" type="image/webp"/><source srcSet="/content/articles/dither/boat-web-dither.jpeg" type="image/jpeg"/><img src="/content/articles/dither/boat-web-dither.jpeg" alt="Dithered image"/></picture><figcaption>Web safe palette, dithered</figcaption></figure><div></div></div>
<p>These days, most displays are capable of showing <em>at least</em> 16.7 million colors, and modern compression algorithms are <a href="https://www.simplethread.com/why-your-website-should-not-use-dithered-images/">far more effective</a> at reducing file size while preserving colors and detail than any form of dithering with reduced color depth. Nevertheless, dithering is still useful in some situations, and can also be used for aesthetic effect.</p>
<h2>How dithering works</h2>
<p>We&#x27;ve seen how we can create different colors by mixing a few base colors—we&#x27;ll call these <em>primaries</em>. In this section we&#x27;ll explore different ways to decide where to mix which primaries to best reproduce the original, full-color image. To make things simpler and the effects of dithering clearer, we&#x27;ll go back to pure black and white for the moment.</p>
<p>Dithering algorithms will be presented in pseudocode along an interactive demonstration of the results, following some conventions:</p>
<ul>
<li><code>input</code> and <code>output</code> are image buffers. Pixels are read and set by <code>[x, y]</code> coordinates.</li>
<li>Images are assumed to be grayscale unless otherwise specified. Grayscale pixel values are referred to as <code>value</code> and treated as numbers, while color pixel values are referred to as <code>color</code> and have <code>r</code>, <code>g</code>, and <code>b</code> number members.</li>
<li>Values (grayscale or RGB) are in the range [0, 1].</li>
</ul>
<p>The interactive demos will use this grayscale image:</p>
<div class="ImageGrid_grid__gBvFf ImageGrid_noScroll___lpY0"><figure><picture><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture></figure><div></div></div>
<h2>Thresholding</h2>
<p>Thresholding is the conversion to a reduced color range itself: the brightness or color values for each pixel are compared against a numerical <em>threshold</em> to determine which color will be used. While not dithering in itself, all dithering methods do this at some point, so it&#x27;s a good place to start.</p>
<p>The thresholding process for converting grayscale to black and white is very simple:</p>
<pre><code>for (x, y) in input
  value = input[x, y]
  output[x, y] = if (value &lt; t) 0; else 1
</code></pre>
<p>Where <code>t</code> is the threshold that controls whether a certain value should resolve to black or white. Try dragging the slider for <code>t</code> towards each end.</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><picture class="DemoCommon_demoContent__zWTmZ"><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><canvas class="DemoCommon_canvas__RJB50" style="opacity:1"></canvas></div><div class="DemoCommon_controls___YFhV"><label><span><code>t=<!-- -->0.50</code></span><input type="range" autoComplete="off" value="0.5" min="0" max="1" step="0.01"/></label><label>Show original<input type="checkbox"/><div class="toggle-slider"></div></label></div></div>
<p>When dithering, we&#x27;ll always use a balanced threshold value of 0.5.</p>
<h2>Random dithering</h2>
<p>This is the simplest form of dithering: it just adds random noise to the image before reducing the colors. Random noise dithering code might look something like this:</p>
<pre><code>for (x, y) in input
  value = input[x, y]
  noise = k * (random(0, 1) - 0.5)
  output[x, y] = if (value + noise &lt; 0.5) 0; else 1
</code></pre>
<p>The parameter <code>k</code> controls the amplitude or “amount” of noise applied to the image. You can try it out below:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><picture class="DemoCommon_demoContent__zWTmZ"><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><canvas class="DemoCommon_canvas__RJB50" style="opacity:1"></canvas></div><div class="DemoCommon_controls___YFhV"><label><span><code>k=<!-- -->0.50</code></span><input type="range" autoComplete="off" value="0.5" min="0" max="1" step="0.01"/></label><label>Show original<input type="checkbox"/><div class="toggle-slider"></div></label></div></div>
<p>This works because we&#x27;re adding some “fuzziness” to the image, making some pixels pass the threshold when they normally wouldn&#x27;t. Below is a visual demonstration of how noise dithering works.</p>
<p>The graph takes a one-dimensional “slice” of a flat gray color shown in the “target” box, placing brightness along the y axis. The <em><code>white line</code></em> indicates the threshold, while the points connected by the <code>red line</code> represent sampled points (in a real image, these would be pixels). The color of each point is its value after thresholding. The “sample average” box shows the average of all sampled points <em>after</em> thresholding.</p>
<p>As you can see, for the initial brightness level of 35% the sample average is black, because 35% is less than the 50% threshold and so <em>all</em> points become black. Try adding some noise by dragging the <code>k</code> slider all the way to the right:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><div class="DemoRandomGraph_colorPreview__kmBHL"><div style="background-color:hsl(0, 0%, 35%)"></div><span>Target</span><div style="background-color:hsl(0, 0%, 0%)"></div><span>Sample average</span></div><canvas class="DemoCommon_canvas__RJB50 DemoRandomGraph_canvas__xjhb3"></canvas></div><div class="DemoCommon_controls___YFhV"><label>Brightness<input type="range" autoComplete="off" value="0.35" min="0" max="1" step="0.005"/></label><label>Samples<input type="range" autoComplete="off" value="15" min="15" max="150" step="1"/></label><label><span><code>k=<!-- -->0.00</code></span><input type="range" autoComplete="off" value="0" min="0" max="1" step="0.01"/></label></div></div>
<p>As you add noise, some points go above the threshold and become white, bringing the average closer to the original 35% gray. Because the noise is “centered” around the original brightness, the average value will tend to get closer to the value as you add more samples. Try playing around with different brightness levels, noise levels, and sample sizes before moving on.</p>
<p>The problem with this approach becomes clear by looking at the results: among other things, it just looks bad. While adding random noise does help approximate the right proportions of black and white for each part of the image, it drowns out most details and the results are, expectedly, noisy. We can do better.</p>
<h2>Error diffusion</h2>
<p>Error diffusion dithering is simple in principle and very effective. Instead of just adding noise at random, we measure the <em>error</em> for a pixel (how much we “missed” by when assigning a primary), and then distribute or <em>diffuse</em> that error along adjacent pixels. This way if we made a pixel darker than it should be, we&#x27;ll make the adjacent pixels a little brighter to compensate, and viceversa. An error diffusion algorithm might look something like this:</p>
<pre><code>number[x, y] errorMap // Error for each pixel, initialized to zero

for (x, y) in input
  value = input[x, y] + errorMap[x, y]
  output[x, y] = if (value &lt; 0.5) 0; else 1

  error = value - output[x, y]

  // Error diffusion across pixels to the right and below
  errorMap[x + 1, y] = error / 2
  errorMap[x, y + 1] = error / 2
</code></pre>
<p>The result looks like this (Click to view in detail):</p>
<div class="ImageGrid_grid__gBvFf ImageGrid_pixelated__S3xRt ImageGrid_noScroll___lpY0"><figure><picture><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><figcaption>Original image</figcaption></figure><figure><picture><source srcSet="/content/articles/dither/tram-ed-simple.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-ed-simple.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-ed-simple.jpeg" alt="Error Diffusion dithered"/></picture><figcaption>Error Diffusion dithering</figcaption></figure><div></div></div>
<p>While there are still noticeable patterns, this is already much cleaner than simple random noise dithering. However, we can improve the error diffusion algorithm even further.</p>
<p>The above implementation uses an overly simplified <em>diffusion pattern</em>: half the error is propagated to the pixel to the right, half to the pixel below. If we were to draw it as a matrix, it would look something like this:</p>
<pre><code>* 1
1 .

(/2)
</code></pre>
<p>Where <code>*</code> is the source pixel, and each number represents the portion of error propagated to that pixel. <code>(/2)</code> indicates that all numbers are divided by two.</p>
<p>In practice, more complex diffusion patterns are used to achieve better results. Patterns that distribute error across more pixels usually result in a smoother image. You can compare some of the most popular ones below (click each image to view in detail):</p>
<div class="ImageGrid_grid__gBvFf ImageGrid_pixelated__S3xRt" style="--min-size:30ch"><figure><picture><source srcSet="/content/articles/dither/tram-ed-fs.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-ed-fs.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-ed-fs.jpeg" alt="Floyd-Steinberg"/></picture><figcaption>Floyd-Steinberg</figcaption></figure><figure><picture><source srcSet="/content/articles/dither/tram-ed-jjn.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-ed-jjn.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-ed-jjn.jpeg" alt="Minimum Average Error"/></picture><figcaption>Minimum Average Error</figcaption></figure><figure><picture><source srcSet="/content/articles/dither/tram-ed-stucki.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-ed-stucki.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-ed-stucki.jpeg" alt="Stucki"/></picture><figcaption>Stucki</figcaption></figure><figure><picture><source srcSet="/content/articles/dither/tram-ed-sierra.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-ed-sierra.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-ed-sierra.jpeg" alt="Sierra"/></picture><figcaption>Sierra</figcaption></figure><div></div></div>
<p>Error diffusion is a much better algorithm than simple random noise, and is often used for dithering static images. It works especially well with very large color palettes, for example, when reducing a camera&#x27;s 14-bit image to standard 8-bit color. It&#x27;s not without its drawbacks, however. With limited palettes, error diffusion dithering can produce very visible noise, color bands and “ghosts” as seen in the image below:</p>
<div class="ImageGrid_grid__gBvFf ImageGrid_pixelated__S3xRt ImageGrid_noScroll___lpY0"><figure><picture><source srcSet="/content/articles/dither/flower.webp" type="image/webp"/><source srcSet="/content/articles/dither/flower.jpeg" type="image/jpeg"/><img src="/content/articles/dither/flower.jpeg" alt="Error dithering artifacts"/></picture></figure><div></div></div>
<p>The other major drawback is related to the way error diffusion works: because the final value of a pixel depends on every single pixel that came before it, it can&#x27;t be used with parallel processing (for instance in GPUs). This makes it rather slow to compute in real time, which is why you didn&#x27;t see any interactive examples in this section.</p>
<p>Also because of this, it doesn&#x27;t work very well for animation or video, as a single pixel change can make the entire image shift around:</p>
<div class="ImageGrid_grid__gBvFf ImageGrid_pixelated__S3xRt ImageGrid_noScroll___lpY0"><figure><picture><source srcSet="/content/articles/dither/tram-motion-original.gif" type="image/gif"/><img src="/content/articles/dither/tram-motion-original.gif" alt="Error dithering animation"/></picture><figcaption>Original animation, with a single moving pixel</figcaption></figure><figure><picture><source srcSet="/content/articles/dither/tram-motion-ed.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-motion-ed.gif" type="image/gif"/><img src="/content/articles/dither/tram-motion-ed.gif" alt="Error dithering animation"/></picture><figcaption>Noise patterns shift throughout the image</figcaption></figure><div></div></div>
<p>Next up, we&#x27;ll look at a dithering method that solves these issues.</p>
<h2>Ordered dithering</h2>
<p>An ordered dithering algorithm solves the problems of error diffusion by making the calculations for each pixel entirely independent from each other. We can use the random noise example from earlier as a starting point:</p>
<pre><code>for (x, y) in input
  value = input[x, y]
  noise = k * (random(0, 1) - 0.5)
  output[x, y] = if (value + noise &lt; 0.5) 0; else 1
</code></pre>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><picture class="DemoCommon_demoContent__zWTmZ"><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><canvas class="DemoCommon_canvas__RJB50" style="opacity:1"></canvas></div><div class="DemoCommon_controls___YFhV"><label><span><code>k=<!-- -->0.50</code></span><input type="range" autoComplete="off" value="0.5" min="0" max="1" step="0.01"/></label><label>Show original<input type="checkbox"/><div class="toggle-slider"></div></label></div></div>
<p>This algorithm is stateless: it doesn&#x27;t keep any internal state, and operates on each pixel independently. In other words, there&#x27;s no code outside the main pixel loop.</p>
<p>This example can be rewritten to think of the noise as adding to the <em>threshold</em>, rather than the input:</p>
<pre><code>for (x, y) in input
  value = input[x, y]
  noise = k * (random(0, 1) - 0.5)
  threshold = 0.5 + noise
  output[x, y] = if (value &lt; threshold) 0; else 1
</code></pre>
<p>This method is already very close to ordered dithering. Ordered dithering differs from our random noise example in that the threshold is sampled from a predetermined <em>threshold map</em>, rather than calculated randomly:</p>
<pre><code>number[n, m] thresholdMap // Threshold map of size n * m
// Initialize threshold map with some values

for (x, y) in input
  value = input[x, y]
  threshold = thresholdMap[x % n, y % m]
  output[x, y] = if (value &lt; threshold) 0; else 1
</code></pre>
<p>We also lose the parameter <code>k</code>, which controls the noise profile in the previous example. Here, the threshold map provides all the information we need.</p>
<p>The threshold map doesn&#x27;t need to be the same size as the image: it is “tiled” as many times as necessary in both dimensions. This leaves only the matter of filling our threshold map with some values.</p>
<h3>Understanding threshold maps</h3>
<p>To understand what threshold maps are and why they work, let&#x27;s go back to the very first example with the black and white tiles. Try dragging the slider all the way to the right:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG"><canvas class="DemoCommon_canvas__RJB50"></canvas></div><div class="DemoCommon_controls___YFhV"><label>Brightness<input type="range" autoComplete="off" value="0" min="0" max="16" step="1"/></label></div></div>
<p>As the amount of white pixels increases, the entire square becomes brighter. The square is 16 (4×4) pixels in size and has a total of 17 possible brightness levels, from no white pixels to all 16.</p>
<p>Knowing this, if we can reduce our image to 4×4 pixel tiles and 17 brightness levels, we can assign a pattern to each possible brightness:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><picture class="DemoCommon_demoContent__zWTmZ"><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><canvas class="DemoCommon_canvas__RJB50" style="opacity:1"></canvas></div><div class="DemoCommon_controls___YFhV"><label>Use pattern<input type="checkbox"/><div class="toggle-slider"></div></label></div></div>
<div class="note"><p>You might notice the image looks too bright and washed out when using the patterns. This happens because we&#x27;re not doing any <em>gamma correction</em>. What gamma correction is and why it&#x27;s necessary will be explained in the next article in this series.</p></div>
<p>The problem with this approach is we lose a lot of resolution: As long as we assign one pattern per tile, the number of brightness levels is limited by the size of the tiles. Instead, we can reduce the tile size, and have the 4×4 pattern cover multiple tiles. Try changing the tile size to 2×2 or even 1×1:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><picture class="DemoCommon_demoContent__zWTmZ"><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><canvas class="DemoCommon_canvas__RJB50" style="opacity:1"></canvas></div><div class="DemoCommon_controls___YFhV"><div class="Radio_radio__8MF3k"><legend>Tile size</legend><div><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_pattern" value="1"/><span class="Radio_label__O9_rk">1 × 1</span></label><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_pattern" value="2"/><span class="Radio_label__O9_rk">2 × 2</span></label><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_pattern" value="4" checked=""/><span class="Radio_label__O9_rk">4 × 4</span></label></div></div><label>Use pattern<input type="checkbox"/><div class="toggle-slider"></div></label></div></div>
<p>At a tile size of 1×1, each tile covers a single pixel—there is no resolution loss at all! This is how ordered dithering works: each pixel takes its color from a different part of the repeating pattern, depending on its own value.</p>
<h3>Threshold map patterns</h3>
<p>Let&#x27;s go back to the grid example one last time. Drag the slider slowly towards the highest brightness, paying attention to the position of white pixels:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG"><canvas class="DemoCommon_canvas__RJB50"></canvas></div><div class="DemoCommon_controls___YFhV"><label>Zoom<input type="range" autoComplete="off" value="1" min="0" max="1" step="0.005"/></label><label>Brightness<input type="range" autoComplete="off" value="0" min="0" max="16" step="1"/></label></div></div>
<p>As you increase brightness, white pixels start appearing in a certain pattern. We can see the pattern more clearly by painting each tile with the brightness it needs to be “turned on”—in other words, its <em>threshold</em>—instead of white:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG"><canvas class="DemoCommon_canvas__RJB50"></canvas></div><div class="DemoCommon_controls___YFhV"><label>Zoom<input type="range" autoComplete="off" value="1" min="0" max="1" step="0.005"/></label><label>Brightness<input type="range" autoComplete="off" value="0" min="0" max="16" step="1"/></label></div></div>
<p>The pattern you see in this last example with brightness turned all the way up is the actual threshold map. Try zooming out to see it repeating.</p>
<p>This pattern is a 4×4 <a href="https://en.wikipedia.org/wiki/Ordered_dithering#Threshold_map">bayer matrix</a>, a common threshold map for ordered dithering. It is a mathematically defined matrix of size N × M, containing all values in the range <code>[0; M × N)</code> such that each number is as far as possible from its immediate succesor. For example, the smallest 2×2 bayer matrix is</p>
<pre><code>0 3
2 1
</code></pre>
<p>For dithering, the matrix is normalized: every value is divided by <code>N × M</code>, so we get threshold values between 0 and 1. Ordered dithering with a bayer matrix is mathematically very accurate, but produces noticeable artifacts in the form of a characteristic cross-hatch pattern. You can try out different matrix sizes below:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><picture class="DemoCommon_demoContent__zWTmZ"><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><canvas class="DemoCommon_canvas__RJB50" style="opacity:1"></canvas></div><div class="DemoCommon_controls___YFhV"><div class="Radio_radio__8MF3k"><legend>Map size</legend><div><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_bayer" value="2"/><span class="Radio_label__O9_rk">2 × 2</span></label><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_bayer" value="4"/><span class="Radio_label__O9_rk">4 × 4</span></label><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_bayer" value="8" checked=""/><span class="Radio_label__O9_rk">8 × 8</span></label></div></div><label>Show original<input type="checkbox"/><div class="toggle-slider"></div></label></div></div>
<p>The cross-hatch pattern produced by a bayer matrix can sometimes be desirable for aesthetic reasons, but might also be unwanted. In these cases, a threshold map without any discernible patterns would be best. Random white noise, as we&#x27;ve seen, doesn&#x27;t work. Ideally we want something with as few “large scale” or low-frequency patterns as possible: blue noise.</p>
<p><a href="http://momentsingraphics.de/BlueNoise.html">Generating blue noise</a> is outside the scope of this article. For our purposes, we can just use pre-generated blue noise textures as a threshold map (the <a href="http://momentsingraphics.de/BlueNoise.html">linked site</a> has plenty available to download). You can try out ordered dithering with a blue noise threshold map below:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><picture class="DemoCommon_demoContent__zWTmZ"><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><canvas class="DemoCommon_canvas__RJB50" style="opacity:1"></canvas></div><div class="DemoCommon_controls___YFhV"><div class="Radio_radio__8MF3k"><legend>Map size</legend><div><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_blueNoise" value="16"/><span class="Radio_label__O9_rk">16 × 16</span></label><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_blueNoise" value="64" checked=""/><span class="Radio_label__O9_rk">64 × 64</span></label></div></div><label>Show original<input type="checkbox"/><div class="toggle-slider"></div></label></div></div>
<p>Other patterns can be used as well—there&#x27;s no restriction to what can be in a threshold map. For example, it can be used to form a coarse, halftone-like pattern:</p>
<div class="DemoCommon_container__wCuSx"><div class="DemoCommon_demoFrame__sy1dG DemoCommon_wide__AEvp5"><picture class="DemoCommon_demoContent__zWTmZ"><source srcSet="/content/articles/dither/tram-original.webp" type="image/webp"/><source srcSet="/content/articles/dither/tram-original.jpeg" type="image/jpeg"/><img src="/content/articles/dither/tram-original.jpeg" alt="Original image"/></picture><canvas class="DemoCommon_canvas__RJB50" style="opacity:1"></canvas></div><div class="DemoCommon_controls___YFhV"><div class="Radio_radio__8MF3k"><legend>Map size</legend><div><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_halftone" value="4"/><span class="Radio_label__O9_rk">4 × 4</span></label><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_halftone" value="6"/><span class="Radio_label__O9_rk">6 × 6</span></label><label class="Radio_radioButton__uCmNT"><input type="radio" name="demo_halftone" value="8" checked=""/><span class="Radio_label__O9_rk">8 × 8</span></label></div></div><label>Show original<input type="checkbox"/><div class="toggle-slider"></div></label></div></div>
<p>Ordered dithering is the most versatile method: it can be used with any number of patterns to achieve different looks, and because each pixel is processed independently it is ideal for animation or moving images. The algorithm can also be implemented on the GPU, which makes real-time dithering feasible.</p>
<h2>Conclusion</h2>
<p>So far, we&#x27;ve learned what dithering is, why it&#x27;s useful (or fun), and how it works. In the next part, we&#x27;ll explore how we can expand our dithering algorithms to work in color, with an arbitrary set of primaries or <em>color palette</em>.</p></article></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/articles/dither","query":{},"buildId":"78eLqVSpZallak_ZN_6EA","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>